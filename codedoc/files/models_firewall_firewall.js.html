<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>models/firewall/firewall.js - FWCloud API REST Documentation</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="http://foswiki.soltecsis.com/codedoc/soltecsis-logo1.png" title="FWCloud API REST Documentation"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.0.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/ClusterRouter.html">ClusterRouter</a></li>
                                <li><a href="../classes/CompileRouter.html">CompileRouter</a></li>
                                <li><a href="../classes/FirewallModel.html">FirewallModel</a></li>
                                <li><a href="../classes/FirewallRouter.html">FirewallRouter</a></li>
                                <li><a href="../classes/FwcloudModel.html">FwcloudModel</a></li>
                                <li><a href="../classes/FwcloudRouter.html">FwcloudRouter</a></li>
                                <li><a href="../classes/IpobjModel.html">IpobjModel</a></li>
                                <li><a href="../classes/IpobjsRouter.html">IpobjsRouter</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/Cluster.html">Cluster</a></li>
                                <li><a href="../modules/Compile.html">Compile</a></li>
                                <li><a href="../modules/Firewall.html">Firewall</a></li>
                                <li><a href="../modules/FirewallExport.html">FirewallExport</a></li>
                                <li><a href="../modules/Fwcloud.html">Fwcloud</a></li>
                                <li><a href="../modules/Ipobjs.html">Ipobjs</a></li>
                                <li><a href="../modules/OpenVPN.html">OpenVPN</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: models/firewall/firewall.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
var db = require(&#x27;../../db.js&#x27;);
/**
 * Module to manage Firewalls data
 *
 * @module Firewall
 * 
 * @requires db
 * 
 */

/**
 * Class to manage firewalls data
 *
 * @class FirewallModel
 * @uses db
 * 
 */
var firewallModel = {};
//Export the object
module.exports = firewallModel;
/**
 * Property Table
 *
 * @property tableModel
 * @type &quot;firewall&quot;
 * @private
 * 
 */
var tableModel = &quot;firewall&quot;;
var logger = require(&#x27;log4js&#x27;).getLogger(&quot;app&quot;);
var utilsModel = require(&quot;../../utils/utils.js&quot;);
var interfaceModel = require(&#x27;../../models/interface/interface&#x27;);
const openvpnModel = require(&#x27;../../models/vpn/openvpn&#x27;);
var User__firewallModel = require(&#x27;../../models/user/user__firewall&#x27;);
var Policy_rModel = require(&#x27;../../models/policy/policy_r&#x27;);
var fwcTreemodel = require(&#x27;../tree/tree&#x27;);
const config = require(&#x27;../../config/config&#x27;);
var firewall_Data = require(&#x27;../../models/data/data_firewall&#x27;);

/**
 * Get Firewalls by User
 *  
 * @method getFirewalls
 * 
 * @param {Integer} iduser User identifier
 * @param {Function} callback    Function callback response
 * 
 *       callback(error, Rows)
 * 
 * @return {ARRAY of Firewall objects} Returns &#x60;ARRAY OBJECT FIREWALL DATA&#x60; 
 * 
 * Table: __firewall__
 * 
 *           id	int(11) AI PK
 *           cluster	int(11)
 *           fwcloud	int(11)
 *           name	varchar(255)
 *           comment	longtext
 *           created_at	datetime
 *           updated_at	datetime
 *           by_user	int(11)
 */
firewallModel.getFirewalls = (iduser, callback) =&gt; {
	db.get(function (error, connection) {
		if (error)
			callback(error, null);
		var sql = &#x27;SELECT T.* &#x27; +
				&#x27; , I.name as interface_name, O.name as ip_name, O.address as ip &#x27; +
				&#x27; FROM &#x27; + tableModel +
				&#x27; T INNER JOIN user__firewall U ON T.id=U.id_firewall AND U.id_user=&#x27; + connection.escape(iduser) + &#x27; AND U.allow_access=1 &#x27; +
				&#x27; LEFT join interface I on I.id=T.install_interface &#x27; +
				&#x27; LEFT join ipobj O on O.id=T.install_ipobj and O.interface=I.id &#x27; +
				&#x27; ORDER BY T.id&#x27;;
		logger.debug(sql);
		connection.query(sql, function (error, rows) {
			if (error)
				callback(error, null);
			else {
				Promise.all(rows.map(utilsModel.decryptDataUserPass))
						.then(data =&gt; {
							callback(null, data);
						})
						.catch(e =&gt; {
							callback(e, null);
						});
			}
		});
	});
};

/**
 * Get Firewalls by User and ID
 *  
 * @method getFirewall
 * 
 * @param {Integer} iduser User identifier
 * @param {Integer} id firewall identifier
 * @param {Function} callback    Function callback response
 * 
 *       callback(error, Rows)
 * 
 * @return {Firewall object} Returns &#x60;OBJECT FIREWALL DATA&#x60; 
 * 
 * Table: __firewall__
 * 
 *           id	int(11) AI PK
 *           cluster	int(11)
 *           fwcloud	int(11)
 *           name	varchar(255)
 *           comment	longtext
 *           created_at	datetime
 *           updated_at	datetime
 *           by_user	int(11)
 */
firewallModel.getFirewall = function (req) {
	return new Promise((resolve, reject) =&gt; {
		var sql = &#x27;SELECT T.* &#x27; +
				&#x27; , I.name as interface_name, O.name as ip_name, O.address as ip &#x27; +
				&#x27; , M.id as id_fwmaster &#x27; +
				&#x27; FROM &#x27; + tableModel + &#x27; T INNER JOIN user__firewall U ON T.id=U.id_firewall AND U.id_user=&#x27; + req.session.user_id +
				&#x27; LEFT join interface I on I.id=T.install_interface &#x27; +
				&#x27; LEFT join ipobj O on O.id=T.install_ipobj and O.interface=I.id &#x27; +
				&#x27; LEFT JOIN firewall M on M.cluster=T.cluster and M.fwmaster=1 &#x27; +
				&#x27; WHERE T.id = &#x27; + req.body.firewall + &#x27; AND T.fwcloud=&#x27; + req.body.fwcloud + &#x27;  AND U.allow_access=1&#x27;;
		//logger.debug(sql);
		req.dbCon.query(sql, (error, rows) =&gt; {
			if (error) return reject(error);

			Promise.all(rows.map(utilsModel.decryptDataUserPass))
			.then(data =&gt; resolve(data))
			.catch(error =&gt; reject(error));
		});
	});
};

/**
 * Get Firewall SSH connection data
 *  
 * @method getFirewallSSH
 * 
 * @param {Integer} iduser User identifier
 * @param {Integer} id firewall identifier
 * @param {Function} callback    Function callback response
 * 
 *       callback(error, Rows)
 * 
 * @return {Firewall object} Returns &#x60;OBJECT FIREWALL DATA&#x60; 
 * 
 * Table: __firewall__
 * 
 *           id	int(11) AI PK
 *           cluster	int(11)
 *           fwcloud	int(11)
 *           name	varchar(255)
 *           comment	longtext
 *           created_at	datetime
 *           updated_at	datetime
 *           by_user	int(11)
 */
firewallModel.getFirewallSSH = function (req) {
	return new Promise(async (resolve, reject) =&gt; {
		try {
			var data = await firewallModel.getFirewall(req);

			// Obtain SSH connSettings for the firewall to which we want install the policy.
			var SSHconn = {
				host: data[0].ip,
				port: data[0].install_port,
				username: data[0].install_user,
				password: data[0].install_pass
			}

			// If we have ssh user and pass in the body of the request, then these data have preference over the data stored in database.
			if (req.body.sshuser &amp;&amp; req.body.sshpass) {
				SSHconn.username = req.body.sshuser;
				SSHconn.password = req.body.sshpass;
			}  

			// If we have no user or password for the ssh connection, then error.
			if (!SSHconn.username || !SSHconn.password)
				throw(new Error(&#x27;User or password for the SSH connection not found&#x27;));

			data.SSHconn = SSHconn;
			resolve(data);
		} catch(error) { reject(error) }
	});
};

/**
 * Get Firewall Access by Locked 
 *  
 * @method getFirewallLockedAccess
 * 
 * @param {Integer} iduser User identifier
 * @param {Integer} idfirewall firewall identifier
 * @param {Integer} fwcloud fwcloud identifier 
 * @param {Function} callback    Function callback response
 * 
 *       callback(error, Rows)
 * 
 * @return {Boolean} Returns &#x60;LOCKED STATUS&#x60; 
 * 
 */
firewallModel.getFirewallAccess = accessData =&gt; {
	return new Promise((resolve, reject) =&gt; {
		db.get(function (error, connection) {
			if (error) return reject(error);
			
			//CHECK FIREWALL PERIMSSIONS
			var sql = &#x27;SELECT T.* FROM &#x27; + tableModel + &#x27; T &#x27; +
				&#x27; INNER JOIN user__firewall U ON T.id=U.id_firewall AND U.id_user=&#x27; + accessData.iduser +
				&#x27; WHERE T.id=&#x27; + accessData.firewall +
				&#x27; AND T.fwcloud=&#x27; + accessData.fwcloud + &#x27; AND U.allow_access=1 AND U.allow_edit=1&#x27;;
			connection.query(sql, function (error, row) {
				if (error) return reject(error);
				
				resolve((row &amp;&amp; row.length&gt;0) ? true : false);
			});
		});
	});
};

/**
 * Get Firewalls by User and Cluster
 *  
 * @method getFirewallCluster
 * 
 * @param {Integer} iduser User identifier
 * @param {Integer} idcluster Cluster identifier
 * @param {Function} callback    Function callback response
 * 
 *       callback(error, Rows)
 * 
 * @return {ARRAY of Firewall objects} Returns &#x60;ARRAY OBJECT FIREWALL DATA&#x60; 
 * 
 * Table: __firewall__
 * 
 *           id	int(11) AI PK
 *           cluster	int(11)
 *           fwcloud	int(11)
 *           name	varchar(255)
 *           comment	longtext
 *           created_at	datetime
 *           updated_at	datetime
 *           by_user	int(11)
 */
firewallModel.getFirewallCluster = function (iduser, idcluster, callback) {
	db.get(function (error, connection) {
		if (error) return callback(error, null);
		var sql = &#x27;SELECT T.* &#x27; +
			&#x27; , I.name as interface_name, O.name as ip_name, O.address as ip &#x27; +
			&#x27; FROM &#x27; + tableModel + &#x27; T INNER JOIN user__firewall U ON T.id=U.id_firewall AND U.id_user=&#x27; + connection.escape(iduser) +
			&#x27; LEFT join interface I on I.id=T.install_interface &#x27; +
			&#x27; LEFT join ipobj O on O.id=T.install_ipobj and O.interface=I.id &#x27; +
			&#x27; WHERE cluster =  &#x27; + connection.escape(idcluster) + &#x27;  AND U.allow_access=1 &#x27; +
			&#x27; ORDER BY T.fwmaster desc, T.id&#x27;;
		connection.query(sql, function (error, rows) {
			if (error)
				callback(error, null);
			else {
				Promise.all(rows.map(utilsModel.decryptDataUserPass))
						.then(data =&gt; {
							Promise.all(data.map(getfirewallData))
									.then(dataF =&gt; {
										callback(null, dataF);
									});
						})
						.catch(e =&gt; {
							callback(e, null);
						});
			}
		});
	});
};


function getfirewallData(row) {
	return new Promise((resolve, reject) =&gt; {
		var firewall = new firewall_Data(row);
		resolve(firewall);
	});
}

firewallModel.getFirewallClusterMaster = function (iduser, idcluster, callback) {
	db.get(function (error, connection) {
			if (error)
					callback(error, null);
			var sql = &#x27;SELECT T.* &#x27; +
							&#x27; , I.name as interface_name, O.name as ip_name, O.address as ip &#x27; +
							&#x27; FROM &#x27; + tableModel + &#x27; T INNER JOIN user__firewall U ON T.id=U.id_firewall AND U.id_user=&#x27; + connection.escape(iduser) +
							&#x27; LEFT join interface I on I.id=T.install_interface &#x27; +
							&#x27; LEFT join ipobj O on O.id=T.install_ipobj and O.interface=I.id &#x27; +
							&#x27; WHERE cluster =  &#x27; + connection.escape(idcluster) + &#x27;  AND U.allow_access=1 AND fwmaster=1&#x27;;
			connection.query(sql, function (error, rows) {
					if (error)
							callback(error, null);
					else {
							Promise.all(rows.map(utilsModel.decryptDataUserPass))
											.then(data =&gt; {
													callback(null, data);
											})
											.catch(e =&gt; {
													callback(e, null);
											});
					}
			});
	});
};

/**
 * Get Firewalls by User and Cloud
 *  
 * @method getFirewallCloud
 * 
 * @param {Integer} iduser User identifier
 * @param {Integer} idCloud Cloud identifier
 * @param {Function} callback    Function callback response
 * 
 *       callback(error, Rows)
 * 
 * @return {ARRAY of Firewall objects} Returns &#x60;ARRAY OBJECT FIREWALL DATA&#x60; 
 * 
 * Table: __firewall__
 * 
 *           id	int(11) AI PK
 *           cluster	int(11)
 *           fwcloud	int(11)
 *           name	varchar(255)
 *           comment	longtext
 *           created_at	datetime
 *           updated_at	datetime
 *           by_user	int(11)
 */
firewallModel.getFirewallCloud = function (iduser, fwcloud, callback) {
	db.get(function (error, connection) {
		if (error)
			callback(error, null);
		var sql = &#x27;SELECT T.* &#x27; +
				&#x27; , I.name as interface_name, O.name as ip_name, O.address as ip &#x27; +
				&#x27; FROM &#x27; + tableModel + &#x27; T INNER JOIN user__firewall U ON T.id=U.id_firewall AND U.id_user=&#x27; + connection.escape(iduser) +
				&#x27; LEFT join interface I on I.id=T.install_interface &#x27; +
				&#x27; LEFT join ipobj O on O.id=T.install_ipobj and O.interface=I.id &#x27; +
				&#x27; WHERE T.fwcloud =  &#x27; + connection.escape(fwcloud) + &#x27;  AND U.allow_access=1 &#x27;;
		logger.debug(sql);
		connection.query(sql, function (error, rows) {
			if (error)
				callback(error, null);
			else {
				Promise.all(rows.map(utilsModel.decryptDataUserPass))
						.then(data =&gt; {
							callback(null, data);
						})
						.catch(e =&gt; {
							callback(e, null);
						});
			}
		});
	});
};
/**
 * ADD New Firewall
 *  
 * @method insertFirewall
 * 
 * @param iduser {Integer}  User identifier
 * @param firewallData {Firewall Object}  Firewall Object data
 *       @param firewallData.id {NULL} 
 *       @param firewallData.cluster {Integer} Cluster ID
 *       @param firewallData.fwcloud {Integer} FWcloud ID
 *       @param firewallData.name {string} Firewall Name
 *       @param [firewallData.comment] {String}  comment text 
 * @param {Function} callback    Function callback response
 * 
 *       callback(error, Rows)
 * 
 * @return {CALLBACK RESPONSE}
 * 
 * @example
 * #### RESPONSE OK:
 *    
 *       callback(null, {&quot;insertId&quot;: fwid});
 *       
 * #### RESPONSE ERROR:
 *    
 *       callback(error, null);
 *       
 */
firewallModel.insertFirewall = function (iduser, firewallData) {
	return new Promise((resolve, reject) =&gt; {
		db.get(function (error, connection) {
			if (error)
				reject(error);
			connection.query(&#x27;INSERT INTO &#x27; + tableModel + &#x27; SET ?&#x27;, firewallData, function (error, result) {
				if (error) {
					logger.debug(&quot;SQL ERROR INSERT: &quot;, error);
					logger.debug(&quot;SQL ERROR Data: &quot;, firewallData);
					reject(error);
				} else {
					var fwid = result.insertId;
					connection.query(&#x27;INSERT INTO  user__firewall  SET id_firewall=&#x27; + connection.escape(fwid) + &#x27; , id_user=&#x27; + connection.escape(iduser) + &#x27; , allow_access=1, allow_edit=1&#x27;, function (error, result) {
						if (error) {
							logger.debug(&quot;SQL ERROR USER INSERT: &quot;, error);
							reject(error);
						} else {
							//devolvemos la última id insertada
							//callback(null, {&quot;insertId&quot;: fwid});
							resolve({&quot;insertId&quot;: fwid});
						}
					});
				}
			});
		});
	});
};
/**
 * UPDATE Firewall
 *  
 * @method updateFirewall
 * 
 * @param iduser {Integer}  User identifier
 * @param firewallData {Firewall Object}  Firewall Object data
 *       @param firewallData.id {NULL} 
 *       @param firewallData.cluster {Integer} Cluster ID
 *       @param firewallData.fwcloud {Integer} FWcloud ID
 *       @param firewallData.name {string} Firewall Name
 *       @param [firewallData.comment] {String}  comment text 
 * @param {Function} callback    Function callback response
 * 
 *       callback(error, Rows)
 * 
 * @return {CALLBACK RESPONSE}
 * 
 * @example
 * #### RESPONSE OK:
 *    
 *       callback(null, {&quot;result&quot;: true});
 *       
 * #### RESPONSE ERROR:
 *    
 *       callback(error, null);
 *       
 */
firewallModel.updateFirewall = function (iduser, firewallData, callback) {
	db.get(function (error, connection) {
		if (error)
			callback(error, null);
		var sqlExists = &#x27;SELECT T.id FROM &#x27; + tableModel + &#x27; T INNER JOIN user__firewall U ON T.id=U.id_firewall &#x27; +
				&#x27; AND U.id_user=&#x27; + connection.escape(iduser) +
				&#x27; WHERE T.id = &#x27; + connection.escape(firewallData.id) + &#x27; AND U.allow_access=1 AND U.allow_edit=1 &#x27;;
		logger.debug(sqlExists);
		connection.query(sqlExists, function (error, row) {
			if (row &amp;&amp; row.length &gt; 0) {
				var sql = &#x27;UPDATE &#x27; + tableModel + &#x27; SET name=&#x27; + connection.escape(firewallData.name) + &#x27;, &#x27; +
						&#x27;comment=&#x27; + connection.escape(firewallData.comment) + &#x27;, &#x27; +
						&#x27;install_user=&#x27; + connection.escape(firewallData.install_user) + &#x27;, &#x27; +
						&#x27;install_pass=&#x27; + connection.escape(firewallData.install_pass) + &#x27;, &#x27; +
						&#x27;save_user_pass=&#x27; + connection.escape(firewallData.save_user_pass) + &#x27;, &#x27; +
						&#x27;install_interface=&#x27; + connection.escape(firewallData.install_interface) + &#x27;, &#x27; +
						&#x27;install_ipobj=&#x27; + connection.escape(firewallData.install_ipobj) + &#x27;, &#x27; +
						&#x27;install_port=&#x27; + connection.escape(firewallData.install_port) + &#x27;, &#x27; +
						&#x27;by_user=&#x27; + connection.escape(iduser) + &#x27;, &#x27; +
						&#x27;options=&#x27; + connection.escape(firewallData.options) +
						&#x27; WHERE id=&#x27; + firewallData.id;
				logger.debug(sql);
				connection.query(sql, function (error, result) {
					if (error) {
						callback(error, null);
					} else {
						callback(null, {&quot;result&quot;: true});
					}
				});
			} else {
				callback(null, {&quot;result&quot;: false});
			}
		});
	});
};


// Get the ID of all firewalls who&#x27;s status field is not zero.
firewallModel.getFirewallStatusNotZero = function (fwcloud, data) {
	return new Promise((resolve, reject) =&gt; {
		db.get((error, connection) =&gt; {
			if (error) return reject(error);

			var sql = &#x27;SELECT id,cluster,status FROM &#x27;+tableModel+&#x27; WHERE status!=0 AND fwcloud=&#x27;+connection.escape(fwcloud);
			connection.query(sql, (error, rows) =&gt; {
				if (error) return reject(error);
				if (data) {
					data.fw_status = rows;
					resolve(data);
				} else
					resolve(rows);
			});
		});
	});
};


firewallModel.updateFirewallStatus = function (fwcloud, firewall, status_action) {
	return new Promise((resolve, reject) =&gt; {
		db.get((error, connection) =&gt; {
			if (error) return reject(error);
			var sql=&#x27;UPDATE &#x27;+tableModel+&#x27; SET status=status&#x27;+status_action+
			&#x27; WHERE id=&#x27;+connection.escape(firewall)+&#x27; AND fwcloud=&#x27;+connection.escape(fwcloud);
			//logger.debug(sql);
			connection.query(sql, (error, result) =&gt; {
				if (error) return reject(error);
				resolve({&quot;result&quot;: true});
			});
		});
	});
};

firewallModel.updateFirewallStatusIPOBJ = function (fwcloud, ipobj, ipobj_g, interface, type, status_action) {
	return new Promise((resolve, reject) =&gt; {
		db.get((error, connection) =&gt; {
			if (error) return reject(error);
			var sql=&#x27;UPDATE &#x27;+tableModel+&#x27; F&#x27;+
			&#x27; INNER JOIN policy_r PR ON PR.firewall=F.id&#x27;+
			&#x27; INNER JOIN policy_r__ipobj PRI ON PRI.rule=PR.id&#x27;+
			&#x27; SET F.status=F.status&#x27;+status_action+
			&#x27; WHERE F.fwcloud=&#x27;+connection.escape(fwcloud)+&#x27; AND PRI.ipobj=&#x27;+connection.escape(ipobj)+
			&#x27; AND PRI.ipobj_g=&#x27;+connection.escape(ipobj_g)+&#x27; AND PRI.interface=&#x27;+connection.escape(interface);
			connection.query(sql, (error, result) =&gt; {
				if (error) return reject(error);

				// If ipobj!=-1 we must see if it is part of a group and then update the status of the firewalls that use that group.
				if (ipobj != -1) {
					sql=&#x27;UPDATE &#x27;+tableModel+&#x27; F&#x27;+
					&#x27; INNER JOIN policy_r PR ON PR.firewall=F.id&#x27;+
					&#x27; INNER JOIN policy_r__ipobj PRI ON PRI.rule=PR.id&#x27;+
					&#x27; INNER JOIN ipobj__ipobjg IG ON IG.ipobj_g=PRI.ipobj_g&#x27;+
					&#x27; SET F.status=F.status&#x27;+status_action+
					&#x27; WHERE F.fwcloud=&#x27;+connection.escape(fwcloud)+&#x27; AND IG.ipobj=&#x27;+connection.escape(ipobj);					
					connection.query(sql, (error, result) =&gt; {
						if (error) return reject(error);

						if (type===5 || type===&quot;5&quot;) { // ADDRESS
							// We must see if the ADDRESS is part of a network interface and then update the status of the firewalls that use that network interface.
							sql=&#x27;UPDATE &#x27;+tableModel+&#x27; F&#x27;+
							&#x27; INNER JOIN policy_r PR ON PR.firewall=F.id&#x27;+
							&#x27; INNER JOIN policy_r__ipobj PRI ON PRI.rule=PR.id&#x27;+
							&#x27; INNER JOIN ipobj IPO ON IPO.interface=PRI.interface&#x27;+
							&#x27; SET F.status=F.status&#x27;+status_action+
							&#x27; WHERE F.fwcloud=&#x27;+connection.escape(fwcloud)+&#x27; AND IPO.id=&#x27;+connection.escape(ipobj);	
							connection.query(sql, (error, result) =&gt; {				
								if (error) return reject(error);

								// We must see too if the ADDRESS is part of a network interface that belogns to a host
								// and then update the status of the firewalls that use that host in any of its positions.
								sql=&#x27;UPDATE &#x27;+tableModel+&#x27; F&#x27;+
								&#x27; INNER JOIN policy_r PR ON PR.firewall=F.id&#x27;+
								&#x27; INNER JOIN policy_r__ipobj PRI ON PRI.rule=PR.id&#x27;+
								&#x27; INNER JOIN interface__ipobj IO ON IO.ipobj=PRI.ipobj&#x27;+
								&#x27; INNER JOIN ipobj IPO ON IPO.interface=IO.interface&#x27;+
								&#x27; SET F.status=F.status&#x27;+status_action+
								&#x27; WHERE F.fwcloud=&#x27;+connection.escape(fwcloud)+&#x27; AND IPO.id=&#x27;+connection.escape(ipobj);	
								connection.query(sql, (error, result) =&gt; {				
									if (error) return reject(error);
									resolve({&quot;result&quot;: true});
								});
							});
						} else
							resolve({&quot;result&quot;: true});
					});
				} else
					resolve({&quot;result&quot;: true});
			});
		});
	});
};

firewallModel.cloneFirewall = function (iduser, firewallData) {
	return new Promise((resolve, reject) =&gt; {
		db.get(function (error, connection) {
			if (error) return reject(error);
			var sqlExists = &#x27;SELECT T.id FROM &#x27; + tableModel + &#x27; T INNER JOIN user__firewall U ON T.id=U.id_firewall &#x27; +
			&#x27; AND U.id_user=&#x27; + connection.escape(iduser) +
			&#x27; WHERE T.id = &#x27; + connection.escape(firewallData.id) + &#x27; AND U.allow_access=1 AND U.allow_edit=1 &#x27;;
			connection.query(sqlExists, function (error, row) {
				//NEW FIREWALL
				if (row &amp;&amp; row.length &gt; 0) {
					var sql = &#x27;insert into firewall(cluster,fwcloud,name,comment,by_user,status,install_user,install_pass,save_user_pass,install_interface,install_ipobj,fwmaster,install_port,options) &#x27; +
					&#x27; select cluster,fwcloud,&#x27; + connection.escape(firewallData.name) + &#x27;,&#x27; + connection.escape(firewallData.comment) + &#x27;,&#x27; + connection.escape(iduser) + &#x27; , 3, install_user, install_pass, save_user_pass, install_interface, install_ipobj, fwmaster, install_port, options &#x27; +
					&#x27; from firewall where id= &#x27; + firewallData.id + &#x27; and fwcloud=&#x27; + firewallData.fwcloud;
					connection.query(sql, function (error, result) {
						if (error) {
							reject(error);
						} else {
							var fwid = result.insertId;
							connection.query(&#x27;INSERT INTO  user__firewall  SET id_firewall=&#x27; + connection.escape(fwid) + &#x27; , id_user=&#x27; + connection.escape(iduser) + &#x27; , allow_access=1, allow_edit=1&#x27;, function (error, result) {
								if (error) {
									logger.debug(&quot;SQL ERROR USER INSERT: &quot;, error);
									reject(error);
								} else {
									resolve({&quot;result&quot;: true, &quot;insertId&quot;: fwid});                                    
								}
							});
						}
					});
				} else {
					resolve({&quot;result&quot;: false});
				}
			});
		});
	});
};

firewallModel.updateFWMaster = function (iduser, fwcloud, cluster, idfirewall, fwmaster) {
	return new Promise((resolve, reject) =&gt; {
		db.get(function (error, connection) {
			if (error) return reject(error);
			var sqlExists = &#x27;SELECT T.id FROM &#x27; + tableModel + &#x27; T INNER JOIN user__firewall U ON T.id=U.id_firewall &#x27; +
				&#x27; AND U.id_user=&#x27; + connection.escape(iduser) +
				&#x27; WHERE T.id = &#x27; + connection.escape(idfirewall) + &#x27; AND U.allow_access=1 AND U.allow_edit=1 &#x27;;
			connection.query(sqlExists, (error, row) =&gt; {
				if (error) return reject(error);
				if (row &amp;&amp; row.length &gt; 0) {
					var sql = &#x27;UPDATE &#x27; + tableModel + &#x27; SET &#x27; +
						&#x27;fwmaster = &#x27; + fwmaster + &#x27;, &#x27; +
						&#x27;by_user = &#x27; + connection.escape(iduser) +
						&#x27; WHERE id = &#x27; + idfirewall + &#x27; AND fwcloud=&#x27; + fwcloud + &#x27; AND cluster=&#x27; + cluster;
					connection.query(sql, function (error, result) {
						if (error) return reject(error);
						if (fwmaster == 1) {
							var sql = &#x27;UPDATE &#x27; + tableModel + &#x27; SET &#x27; +
								&#x27;fwmaster = 0, &#x27; +
								&#x27;by_user = &#x27; + connection.escape(iduser) +
								&#x27; WHERE id &lt;&gt; &#x27; + idfirewall + &#x27; AND fwcloud=&#x27; + fwcloud + &#x27; AND cluster=&#x27; + cluster;
							connection.query(sql, function (error, result) {
								if (error) return reject(error);
								resolve({&quot;result&quot;: true});
							});
						} else resolve({&quot;result&quot;: true});
					});
				} else resolve({&quot;result&quot;: false});
			});
		});
	});
};

firewallModel.updateFirewallCluster = function (firewallData) {
	return new Promise((resolve, reject) =&gt; {
		db.get(function (error, connection) {
			if (error) return reject(error);
			var sqlExists = &#x27;SELECT T.id FROM &#x27; + tableModel + &#x27; T INNER JOIN user__firewall U ON T.id=U.id_firewall &#x27; +
					&#x27; AND U.id_user=&#x27; + connection.escape(firewallData.by_user) +
					&#x27; WHERE T.id = &#x27; + connection.escape(firewallData.id) + &#x27; AND U.allow_access=1 AND U.allow_edit=1 &#x27;;
			connection.query(sqlExists, (error, row) =&gt; {
				if (error) return reject(error);
				if (row &amp;&amp; row.length &gt; 0) {
					var sql = &#x27;UPDATE &#x27; + tableModel + &#x27; SET cluster = &#x27; + connection.escape(firewallData.cluster) + &#x27;,&#x27; +
							&#x27;by_user = &#x27; + connection.escape(firewallData.by_user) + &#x27; &#x27; +
							&#x27; WHERE id = &#x27; + firewallData.id;
					connection.query(sql, (error, result) =&gt; {
						if (error) return reject(error);
						resolve({&quot;result&quot;: true});
					});
				} else 
					resolve({&quot;result&quot;: false});
			});
		});
	});
};

firewallModel.removeFirewallClusterSlaves = function (cluster, fwcloud, callback) {

	db.get(function (error, connection) {
		if (error)
			callback(error, null);

		var sql = &#x27;DELETE FROM &#x27; + tableModel +
				&#x27; WHERE cluster = &#x27; + connection.escape(cluster) + &#x27; AND fwcloud=&#x27; + connection.escape(fwcloud) + &#x27; AND fwmaster=0&#x27;;
		connection.query(sql, function (error, result) {
			if (error) {
				callback(error, null);
			} else {
				callback(null, {&quot;result&quot;: true});
			}
		});
	});
};
/**
 * UPDATE Firewall lock status
 *  
 * @method updateFirewallLock
 * 
 * @param iduser {Integer}  User identifier
 * @param firewallData {Firewall Object}  Firewall Object data
 *       @param firewallData.id {NULL} 
 *       @param firewallData.fwcloud {Integer} FWcloud ID
 *       @param firewallData.locked {Integer} Locked status
 * @param {Function} callback    Function callback response
 * 
 *       callback(error, Rows)
 * 
 * @return {CALLBACK RESPONSE}
 * 
 * @example
 * #### RESPONSE OK:
 *    
 *       callback(null, {&quot;result&quot;: true});
 *       
 * #### RESPONSE ERROR:
 *    
 *       callback(error, null);
 *       
 */
firewallModel.updateFirewallLock = function (firewallData, callback) {

	var locked = 1;
	db.get(function (error, connection) {
		if (error)
			callback(error, null);
		var sqlExists = &#x27;SELECT T.id FROM &#x27; + tableModel + &#x27; T INNER JOIN user__firewall U ON T.id=U.id_firewall &#x27; +
				&#x27; AND U.id_user=&#x27; + connection.escape(firewallData.iduser) +
				&#x27; WHERE T.id = &#x27; + connection.escape(firewallData.id) + &#x27; AND U.allow_access=1 AND U.allow_edit=1 &#x27; +
				&#x27; AND (locked=0 OR (locked=1 AND locked_by=&#x27; + connection.escape(firewallData.iduser) + &#x27;)) &#x27;;
		connection.query(sqlExists, function (error, row) {

			if (row &amp;&amp; row.length &gt; 0) {
				var sql = &#x27;UPDATE &#x27; + tableModel + &#x27; SET locked = &#x27; + connection.escape(locked) + &#x27;,&#x27; +
						&#x27;locked_at = CURRENT_TIMESTAMP ,&#x27; +
						&#x27;locked_by = &#x27; + connection.escape(firewallData.iduser) + &#x27; &#x27; +
						&#x27; WHERE id = &#x27; + firewallData.id;
				connection.query(sql, function (error, result) {
					if (error) {
						callback(error, null);
					} else {
						callback(null, {&quot;result&quot;: true});
					}
				});
			} else {
				callback(null, {&quot;result&quot;: false});
			}
		});
	});
};
/**
 * UNLOCK Firewall status
 *  
 * @method updateFirewallUnlock
 * 
 * @param iduser {Integer}  User identifier
 * @param firewallData {Firewall Object}  Firewall Object data
 *       @param firewallData.id {NULL} 
 *       @param firewallData.fwcloud {Integer} FWcloud ID
 *       @param firewallData.locked {Integer} Locked status
 * @param {Function} callback    Function callback response
 * 
 *       callback(error, Rows)
 * 
 * @return {CALLBACK RESPONSE}
 * 
 * @example
 * #### RESPONSE OK:
 *    
 *       callback(null, {&quot;result&quot;: true});
 *       
 * #### RESPONSE ERROR:
 *    
 *       callback(error, null);
 *       
 */
firewallModel.updateFirewallUnlock = function (firewallData, callback) {

	var locked = 0;
	db.get(function (error, connection) {
		if (error)
			callback(error, null);
		var sqlExists = &#x27;SELECT T.id FROM &#x27; + tableModel + &#x27; T INNER JOIN user__firewall U ON T.id=U.id_firewall &#x27; +
				&#x27; AND U.id_user=&#x27; + connection.escape(firewallData.iduser) +
				&#x27; WHERE T.id = &#x27; + connection.escape(firewallData.id) + &#x27; AND U.allow_access=1 AND U.allow_edit=1 &#x27; +
				&#x27; AND (locked=1 AND locked_by=&#x27; + connection.escape(firewallData.iduser) + &#x27;) &#x27;;
		connection.query(sqlExists, function (error, row) {

			if (row &amp;&amp; row.length &gt; 0) {
				var sql = &#x27;UPDATE &#x27; + tableModel + &#x27; SET locked = &#x27; + connection.escape(locked) + &#x27;,&#x27; +
						&#x27;locked_at = CURRENT_TIMESTAMP ,&#x27; +
						&#x27;locked_by = &#x27; + connection.escape(firewallData.iduser) + &#x27; &#x27; +
						&#x27; WHERE id = &#x27; + firewallData.id;
				connection.query(sql, function (error, result) {
					if (error) {
						callback(error, null);
					} else {
						callback(null, {&quot;result&quot;: true});
					}
				});
			} else {
				callback(null, {&quot;result&quot;: false});
			}
		});
	});
};

firewallModel.deleteFirewallPro = fwdata =&gt; {
	return new Promise(async (resolve, reject) =&gt; {
		try {
			const data = await interfaceModel.searchInterfaceInrulesOtherFirewall(fwdata.fwcloud, fwdata.id);
			if (data.result) return resolve({&quot;result&quot;: false, &quot;msg&quot;: &quot;Restricted&quot;, &quot;restrictions&quot;: data});

			await firewallModel.deleteFirewall(fwdata.iduser, fwdata.fwcloud, fwdata.id)
			resolve({&quot;result&quot;: true, &quot;msg&quot;: &quot;Deleted&quot;, &quot;restrictions&quot;: &quot;&quot;});
		} catch(error) { return reject(error) }
	});
};
/**
 * DELETE Firewall
 *  
 * @method deleteFirewall
 * 
 * @param user {Integer}  User identifier
 * @param id {Integer}  Firewall identifier
 * @param {Function} callback    Function callback response
 * 
 *       callback(error, Rows)
 * 
 * @return {CALLBACK RESPONSE}
 * 
 * @example
 * #### RESPONSE OK:
 *    
 *       callback(null, {&quot;result&quot;: true, &quot;msg&quot;: &quot;deleted&quot;});
 *       
 * #### RESPONSE ERROR:
 *    
 *       callback(null, {&quot;result&quot;: false});
 *       
 */
firewallModel.deleteFirewall = (user, fwcloud, firewall) =&gt; {
	return new Promise((resolve, reject) =&gt; {
		db.get((error, dbCon) =&gt; {
			if (error) return reject(error);

			var sql = &#x27;select id from fwc_tree where node_type=&quot;FW&quot; and id_obj=&#x27;+firewall+&#x27; and fwcloud=&#x27;+fwcloud;
			dbCon.query(sql, async (error, row) =&gt; {
				if (error) return reject(error);

				//If exists Id from firewall to remove
				if (row &amp;&amp; row.length &gt; 0) {
					try {
						await openvpnModel.delCfgAll(dbCon,fwcloud,firewall); // Remove all OpenVPN configurations for this firewall.
						await Policy_rModel.deletePolicy_r_Firewall(firewall); //DELETE POLICY, Objects in Positions and firewall rule groups.
						await interfaceModel.deleteInterfacesIpobjFirewall(fwcloud, firewall); // DELETE IPOBJS UNDER INTERFACES
						await interfaceModel.deleteInterfaceFirewall(fwcloud, firewall); //DELETE INTEFACES
						await User__firewallModel.deleteAllUser__firewall(firewall);//DELETE USERS_FIREWALL
						await fwcTreemodel.deleteFwc_TreeFullNode({id: row[0].id, fwcloud: fwcloud, iduser: user}); //DELETE TREE NODES From firewall
						await utilsModel.deleteFolder(config.get(&#x27;policy&#x27;).data_dir+&#x27;/&#x27;+fwcloud+&#x27;/&#x27;+firewall); // DELETE DATA DIRECTORY FOR THIS FIREWALL

						//DELETE FIREWALL from the database.
						var sql = &#x27;DELETE FROM &#x27; + tableModel + &#x27; WHERE id=&#x27; + firewall;
						dbCon.query(sql, (error, result) =&gt; {
							if (error) 
								resolve({&quot;result&quot;: false, &quot;msg&quot;: &quot;Error DELETE FIREWALL: &quot; + error});
							else 
								resolve({&quot;result&quot;: true, &quot;msg&quot;: &quot;deleted&quot;});
						});
					} catch(error) { resolve({&quot;result&quot;: false, &quot;msg&quot;: &quot;ERROR: &quot; + error}) }
				}
			});
		});
	});
}

firewallModel.deleteFirewallFromCluster = (iduser, fwcloud, idfirewall, cluster) =&gt; {
	return new Promise((resolve, reject) =&gt; {
		db.get(function (error, connection) {
			if (error) return reject(error);

			var sqlExists = &#x27;SELECT T.*, A.id as idnode FROM &#x27; + tableModel + &#x27; T INNER JOIN user__firewall U ON T.id=U.id_firewall &#x27; +
				&#x27; AND U.id_user=&#x27; + connection.escape(iduser) +
				&#x27; INNER JOIN fwc_tree A ON A.id_obj = T.id AND A.node_type=&quot;FW&quot; &#x27; +
				&#x27; WHERE T.id = &#x27; + connection.escape(idfirewall) + &#x27; AND U.allow_access=1 AND U.allow_edit=1 AND T.cluster=&#x27; + connection.escape(cluster);
			connection.query(sqlExists, (error, row) =&gt; {
				if (error) return reject(error);

				//If exists Id from firewall to remove
				if (row &amp;&amp; row.length &gt; 0) {
					var rowF = row[0];
					var idNodeFirewall = rowF.idnode;

					//FIREWAL MASTER
					if (rowF.fwmaster === 1) {
						logger.debug(&quot;DELETING FWMASTER: &quot; + idfirewall);

						//TRASPASO de DATOS a PRIMER FIREWALL SLAVE
						var sql = &#x27;SELECT T.id FROM &#x27; + tableModel + &#x27; T &#x27; +
							&#x27; WHERE fwmaster=0 AND  T.cluster=&#x27; + connection.escape(cluster) +
							&#x27; ORDER by T.id limit 1&#x27;;
						logger.debug(&quot;SELECT NEXT FIREWALL SLAVE: &quot;, sql);
						connection.query(sql, async (error, rowS) =&gt; {
							if (rowS &amp;&amp; rowS.length &gt; 0) {
								var idNewFM = rowS[0].id;

								// Rename data directory with the new firewall master id.
								try {
									await utilsModel.renameFirewallDataDir(fwcloud,idfirewall,idNewFM);
								} catch(error) { return reject(error) }

								//UPDATE POLICY_R
								sql = &quot;UPDATE policy_r SET firewall=&quot; + connection.escape(idNewFM) + &quot; WHERE firewall=&quot; + connection.escape(idfirewall);
								connection.query(sql, (error, result) =&gt; {
									if (error) return resolve({&quot;result&quot;: false, &quot;msg&quot;: &quot;Error UPDATE POLICY&quot;});

									//UPDATE POLICY_G
									sql = &quot;UPDATE policy_g SET firewall=&quot; + connection.escape(idNewFM) + &quot; WHERE firewall=&quot; + connection.escape(idfirewall);
									connection.query(sql, (error, result) =&gt; {
										if (error) return resolve({&quot;result&quot;: false, &quot;msg&quot;: &quot;Error UPDATE POLICY GROUPS&quot;});

										//UPDATE INTERFACES
										sql = &quot;UPDATE interface SET firewall=&quot; + connection.escape(idNewFM) + &quot; WHERE firewall=&quot; + connection.escape(idfirewall);
										connection.query(sql, (error, result) =&gt; {
											if (error) return resolve({&quot;result&quot;: false, &quot;msg&quot;: &quot;Error UPDATE INTERFACES&quot;});
											
											//UPDATE NEW FWMASTER
											sql = &quot;UPDATE firewall SET fwmaster=1 WHERE id=&quot; + connection.escape(idNewFM);
											connection.query(sql, function (error, result) {
												if (error) return resolve({&quot;result&quot;: false, &quot;msg&quot;: &quot;Error UPDATE NEW FWMASTER&quot;});

												//UPDATE TREE RECURSIVE FROM IDNODE CLUSTER
												//GET NODE FROM CLUSTER
												sql = &quot;SELECT &quot; + connection.escape(idfirewall) + &quot; as OLDFW, &quot; + connection.escape(idNewFM) + &quot; as NEWFW, T.* FROM fwc_tree T WHERE node_type=&#x27;CL&#x27; AND  id_obj =&quot; + connection.escape(cluster) + &#x27; AND fwcloud=&#x27; + connection.escape(fwcloud);
												logger.debug(&quot;FIRST SQL: &quot;, sql);
												connection.query(sql, function (error, rowT) {
													if (rowT &amp;&amp; rowT.length &gt; 0) {
														var iNodeCluster = rowT[0].id;
														fwcTreemodel.updateIDOBJFwc_TreeFullNode(rowT[0])
																.then(resp =&gt; {
																	//DELETE USERS_FIREWALL
																	User__firewallModel.deleteAllUser__firewall(idfirewall)
																			.then(resp3 =&gt; {
																				//DELETE TREE NODES From firewall
																				var dataNode = {id: idNodeFirewall, fwcloud: fwcloud, iduser: iduser};
																				logger.debug(&quot;----&gt; DELETING TREE FOR NODE:&quot;, dataNode);
																				fwcTreemodel.deleteFwc_TreeFullNode(dataNode)
																						.then(resp4 =&gt; {
																							//DELETE FIREWALL
																							var sql = &#x27;DELETE FROM &#x27; + tableModel + &#x27; WHERE id = &#x27; + connection.escape(idfirewall);
																							connection.query(sql, function (error, result) {
																								if (error) {
																									resolve({&quot;result&quot;: false, &quot;msg&quot;: &quot;Error DELETE FIREWALL: &quot; + error});
																								} else {

																									resolve({&quot;result&quot;: true, &quot;msg&quot;: &quot;deleted&quot;});
																								}

																							});
																						})
																						.catch(e =&gt; {
																							resolve({&quot;result&quot;: false, &quot;msg&quot;: &quot;Error DELETE TREE NODES: &quot; + e});
																						});
																			})
																			.catch(e =&gt; {
																				resolve({&quot;result&quot;: false, &quot;msg&quot;: &quot;Error DELETE USERS: &quot; + e});
																			});

																})
																.catch(e =&gt; {
																	resolve({&quot;result&quot;: false, &quot;msg&quot;: &quot;ERROR: &quot; + e});
																});
													} else {
														resolve({&quot;result&quot;: false, &quot;msg&quot;: &quot;NOT FOUND NODE CLUSTER&quot;});
													}

												});
											});
										});

									});
								});

							//TRAPASO de NODOS
							} else {
								//NO HAY FIREWALL SLAVES
								resolve({&quot;result&quot;: false, &quot;msg&quot;: &quot;Not Exist SLAVE&quot;});
							}
						});

					} else {
						logger.debug(&quot;DELETING FW SLAVE: &quot; + idfirewall);
						//DELETE USERS_FIREWALL
						User__firewallModel.deleteAllUser__firewall(idfirewall)
								.then(resp3 =&gt; {
									//DELETE TREE NODES From firewall
									var dataNode = {id: idNodeFirewall, fwcloud: fwcloud, iduser: iduser};
									logger.debug(&quot;----&gt; DELETING TREE FOR NODE:&quot;, dataNode);
									fwcTreemodel.deleteFwc_TreeFullNode(dataNode)
											.then(resp4 =&gt; {
												//DELETE FIREWALL
												var sql = &#x27;DELETE FROM &#x27; + tableModel + &#x27; WHERE id=&#x27; + connection.escape(idfirewall);
												connection.query(sql, function (error, result) {
													if (error) {
														resolve({&quot;result&quot;: false, &quot;msg&quot;: &quot;Error DELETE FIREWALL: &quot; + error});
													} else {

														resolve({&quot;result&quot;: true, &quot;msg&quot;: &quot;deleted&quot;});
													}

												});
											})
											.catch(e =&gt; {
												resolve({&quot;result&quot;: false, &quot;msg&quot;: &quot;Error DELETE TREE NODES: &quot; + e});
											});
								})
								.catch(e =&gt; {
									resolve({&quot;result&quot;: false, &quot;msg&quot;: &quot;Error DELETE USERS: &quot; + e});
								});
					}
				}
			});///
		});
	});
};

firewallModel.checkBodyFirewall = function (body, isNew) {
	try {
		return new Promise((resolve, reject) =&gt; {
			var param = &quot;&quot;;
			if (!isNew) {
				param = body.id;
				if (param === undefined || param === &#x27;&#x27; || isNaN(param) || param == null) {
					reject(&quot;Firewall ID not valid&quot;);
				}
			}
			param = body.cluster;
			if (param === undefined || param === &#x27;&#x27; || isNaN(param) || param == null) {
				body.cluster = null;
			}

			param = body.name;
			if (param === undefined || param === &#x27;&#x27; || param == null) {
				reject(&quot;Firewall name not valid&quot;);
			}


			param = body.save_user_pass;
			if (param === undefined || param === &#x27;&#x27; || param == null || param == 0) {
				body.save_user_pass = false;
			} else
				body.save_user_pass = true;
			param = body.install_user;
			if (param === undefined || param === &#x27;&#x27; || param == null) {
				body.install_user = &#x27;&#x27;;
			}
			param = body.install_pass;
			if (param === undefined || param === &#x27;&#x27; || param == null) {
				body.install_pass = &#x27;&#x27;;
			}
			param = body.install_interface;
			if (param === undefined || param === &#x27;&#x27; || isNaN(param) || param == null) {
				body.install_interface = null;
			}
			param = body.install_ipobj;
			if (param === undefined || param === &#x27;&#x27; || isNaN(param) || param == null) {
				body.install_ipobj = null;
			}
			param = body.install_port;
			if (param === undefined || param === &#x27;&#x27; || isNaN(param) || param == null) {
				body.install_port = 22;
			}
			param = body.fwmaster;
			if (param === undefined || param === &#x27;&#x27; || isNaN(param) || param == null) {
				body.fwmaster = 0;
			}
			resolve(body);
		});
	} catch (e) {
		reject(&quot;Carch Error: &quot;, e);
	}
};


firewallModel.getFirewallOptions = function (fwcloud, fw) {
	return new Promise((resolve, reject) =&gt; {
		db.get(function (error, connection) {
			if (error) return reject(error);

			let sql = &#x27;SELECT options FROM &#x27; + tableModel +
			&#x27; WHERE fwcloud=&#x27; + connection.escape(fwcloud) + &#x27; AND id=&#x27; + connection.escape(fw);
			connection.query(sql, (error, rows) =&gt; {
				if (error) return reject(error);
				if (rows.length !== 1) return reject(new Error(&#x27;Firewall not found&#x27;));
				resolve(rows[0].options);
			});
		});
	});
}

firewallModel.getMasterFirewallId = function (fwcloud, cluster) {
	return new Promise((resolve, reject) =&gt; {
		db.get((error, connection) =&gt; {
			if (error) return reject(error);

			let sql = &#x27;SELECT id FROM &#x27; + tableModel +
			&#x27; WHERE fwcloud=&#x27; + connection.escape(fwcloud) + &#x27; AND cluster=&#x27; + connection.escape(cluster) + &#x27; AND fwmaster=1&#x27;;
			connection.query(sql, (error, rows) =&gt; {
				if (error) return reject(error);
				if (rows.length !== 1) return reject(new Error(&#x27;Firewall not found&#x27;));
				resolve(rows[0].id);
			});
		});
	});
}

firewallModel.searchFirewallRestrictions = req =&gt; {
	return new Promise(async (resolve, reject) =&gt; {
		try {
			let search = {};
			search.result = false;
			search.restrictions = {};

			const r1 = await interfaceModel.searchInterfaceInrulesOtherFirewall(req.body.fwcloud, req.body.firewall);
		  // For each OpenVPN configuration of the firewall, check that its ipobjs are not being used in other firewalls.
			const r2 = await openvpnModel.searchOpenvpnInrulesOtherFirewall(req);

			if (r1) search.restrictions = utilsModel.mergeObj(search.restrictions, r1.restrictions);
			if (r2) search.restrictions = utilsModel.mergeObj(search.restrictions, r2.restrictions);

			for (let key in search.restrictions) {
				if (search.restrictions[key].length &gt; 0) {
					search.result = true;
					break;
				}
			}
			resolve(search);
		} catch(error) { reject(error) }
	});
};


    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
